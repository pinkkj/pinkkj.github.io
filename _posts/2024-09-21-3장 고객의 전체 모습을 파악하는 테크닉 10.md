---
# Header
title: "3.고객의 전체 모습을 파악하는 테크닉 10"
excerpt: "고객의 전체 모습을 파악하는 테크닉 10"
name: J
writer: J
categories: [데비&추천시스템, 파이썬 데이터분석 실무 테크닉 100] # [메인 카테고리, 서브 카테고리]
tags:
  - [Khuda, ML, data]

toc: true
toc_sticky: true

date: 2024-09-21
last_modified_at: 2024-09-21

# --- 아래 부터 content
---
🔖전제 조건
- 스포츠 센터
  - 종일 회원: 언제든 이용 가능
  - 주간 회원: 낮에만 이용 가능
  - 야간 회원: 밤에만 이용 가능
- 정책
  - 입회비가 들지만, 비정기적으로 입회비 반액 할인이나 입회비 무료 행사를 해서 신규회원을 늘리고 있다.
  - 탈퇴하려면 월말까지 신청하면 그 다음 달 말에 탈퇴가 된다.
- 취급할 데이터

![alt text](/assets/img_20240922/image.png)

# 021.데이터를 읽어 들이고 확인하자

⭐ 어떤 데이터열이 존재하는지, 각 데이터의 관계성과 같은 데이터의 큰 들을 파악하는 것이 중요하다.

```py
import pandas as pd
uselog = pd.read_csv('use_log.csv')
print(len(uselog))
# 197428
uselog.head()
```
![alt text](/assets/img_20240922/image-1.png)
---

```py
customer = pd.read_csv('customer_master.csv')
print(len(customer))
# 4192
customer.head()
```
![alt text](/assets/img_20240922/image-2.png)

- is_deleted: 2019년 3월 시점에 탈퇴한 유저를 시스템에서 빨리 찾기 위한 칼럼.

---

```py
class_master = pd.read_csv('class_master.csv')
print(len(class_master))
# 3
class_master.head()
```
![alt text](/assets/img_20240922/image-3.png)

---


```py
campaign_master = pd.read_csv('campaign_master.csv')
print(len(campaign_master))
# 3
campaign_master.head()
```
![alt text](/assets/img_20240922/image-4.png)

# 022.고객 데이터를 가공하자.

❗고객 데이터(customer)를 가공한다.


### 데이터 유니언

```py
customer_join = pd.merge(customer, class_master, on="class", how="left")
customer_join = pd.merge(customer_join, campaign_master, on="campaign_id", how="left")
customer_join.head()

#확인
print(len(customer))
# 4192
print(len(customer_join))
# 4192
```
![alt text](/assets/img_20240922/image-5.png)

### 결측치 확인

- 조인시 결측치가 들어가는 경우
  - 조인 키x
  - 조인이 잘못될 시

```py
customer_join.isnull().sum()
# end_date 결측치? -> 탈퇴하지 않은 회원!
```
![alt text](/assets/img_20240922/image-6.png)

# 023.고객 데이터를 집계하자

### 고객 데이터 집계

🔖회원 구분

```py
customer_join.groupby("class_name").count()["customer_id"]
```
![alt text](/assets/img_20240922/image-7.png)

🔖캠페인 구분

```py
customer_join.groupby("campaign_name").count()["customer_id"]
```
![alt text](/assets/img_20240922/image-8.png)

🔖성별

```py
customer_join.groupby("gender").count()["customer_id"]
```
![alt text](/assets/img_20240922/image-9.png)

🔖탈퇴?

```py
customer_join.groupby("is_deleted").count()["customer_id"]
```
![alt text](/assets/img_20240922/image-10.png)

🔖start_date가 2018.4.1 ~ 2019.3.31 까지인 가입 인원 집계

```py
customer_join["start_date"] = pd.to_datetime(customer_join["start_date"])
customer_start = customer_join.loc[customer_join["start_date"] > pd.to_datetime("20180401")]
print(len(customer_start))
# 1361
```

# 024.최신 고객 데이터를 집계하자

가장 최근 월(2019.3)의 고객 데이터를 집계해서 현재 고객의 전체 모습을 파악하자.

🔖최근 월로 추출하기 위해서는?<br>
1. 2019.3.31에 탈퇴한 고객과 재적 중인 고객을 추출
2. is_deleted 열로 추출(❗2019년 3월에 탈퇴한 고객은 카운트되지 않기 때문에 주의!)

### 최근 월 고객 집계

```py
customer_join["end_date"] = pd.to_datetime(customer_join["end_date"])
customer_newer = customer_join.loc[(customer_join["end_date"] >= pd.to_datetime("20190331")) | (customer_join["end_date"].isna())]
# isna(): isna 의 경우 결측값이면 True 반환
print(len(customer_newer))
# 2953
customer_newer["end_date"].unique()
# ['NaT', '2019-03-31 00:00:00']
```

🔖회원 구분

```py
customer_newer.groupby("class_name").count()["customer_id"]
```
![alt text](/assets/img_20240922/image-11.png)

🔖캠페인 구분

```py
customer_newer.groupby("campaign_name").count()["customer_id"]
```
![alt text](/assets/img_20240922/image-12.png)

- 전체를 집계: 일반으로 입회한 유저가 72%
- 최근 월 집계: 일반 입회 비율이 81%<br>
  => **입회 캠페인은 회원 비율 변화에 영향을 미친다고 추측!**

🔖성별 구분

```py
customer_newer.groupby("gender").count()["customer_id"]
```
![alt text](/assets/img_20240922/image-13.png)

# 025.이용 이력 데이터를 집계하자

이용 이력 데이터는 고객 데이터와는 달리, 시간적인 요소를 분석할 수 있습니다.

### 월/고객 이용 횟수 집계 결과

```py
uselog["usedate"] = pd.to_datetime(uselog["usedate"])
uselog["연월"] = uselog["usedate"].dt.strftime("%Y%m")
# 문자열로 바꾸기
uselog_months = uselog.groupby(["연월", "customer_id"],as_index = False).count()
# as_index: 이 그룹을 인덱스로 지정할 것인지 여부
uselog_months.rename(columns={"log_id": "count"}, inplace = True)
del uselog_months["usedate"]
uselog_months.head()
```
![alt text](/assets/img_20240922/image-14.png)

### 고객별 월 이용 횟수 집계 결과

```py
uselog_customer = uselog_months.groupby("customer_id").agg(["mean", "median", "max", "min"])["count"]
uselog_customer = uselog_customer.reset_index(drop=False)
# groupby의 영향으로 customer_id가 index에 들어가 있기에 이것을 칼럼으로 변경!
# drop : 제거한 인덱스를 열에 추가할지 여부
uselog_customer.head()
```
![alt text](/assets/img_20240922/image-15.png)

# 026.이용 이력 데이터로부터 정기 이용 플래그를 작성하자

- 정기적: 매주 같은 요일에 왔는지 아닌지로 판단!<br>
  => 고객마다 월/요일별로 집계하고, 최댓값이 4 이상인 요일이 하나라도 있는 회원은 플래그를 1로 처리!

### 고객별 월/요일 집계 결과

```py
uselog["weekday"] = uselog["usedate"].dt.weekday
# 요일을 숫자로 변환(0~6까지의 숫자가 각각 월요일~일요일에 해당)
uselog_weekday = uselog.groupby(["customer_id", "연월", "weekday"], as_index = False).count()[["customer_id", "연월", "weekday", "log_id"]]
uselog_weekday.rename(columns={"log_id":"count"}, inplace=True)
uselog_weekday.head()
```
![alt text](/assets/img_20240922/image-16.png)

### 플래그 작성

```py
uselog_weekday = uselog_weekday.groupby("customer_id", as_index = False).max()[["customer_id", "count"]]
uselog_weekday["routine_flg"] = 0
uselog_weekday["routine_flg"] = uselog_weekday["routine_flg"].where(uselog_weekday["count"]<4, 1)
# "count"가 4미만인 경우 그대로 두고 4 이상인 경우에만 1 대입.
uselog_weekday.head()
```
![alt text](/assets/img_20240922/image-17.png)

# 027.고객 데이터와 이용 이력 데이터를 결합하자

### 고객 데이터와 이용이력데이터 결합

```py
customer_join = pd.merge(customer_join, uselog_customer, on="customer_id", how="left")
customer_join = pd.merge(customer_join, uselog_weekday[["customer_id", "routine_flg"]], on="customer_id", how="left")
customer_join.head()

customer_join.isnull().sum()
# end_date이외에는 결측치x
```
![alt text](/assets/img_20240922/image-18.png)

# 028.회원 기간을 계산하자

- 회원 기간: end_date - start_date(하지만 end_date가 결측치인 경우 20190430으로 채워서 계산)

### 회원 기간 계산

```py
from dateutil.relativedelta import relativedelta
# relativedalta: 날짜 비교 함수
customer_join["calc_date"] = customer_join["end_date"]
customer_join["calc_date"] = customer_join["calc_date"].fillna(pd.to_datetime("20190430"))
customer_join["membership_period"] = 0
for i in range(len(customer_join)):
    delta = relativedelta(customer_join["calc_date"].iloc[i], customer_join["start_date"].iloc[i])
    customer_join["membership_period"].iloc[i] = delta.years*12 + delta.months
customer_join.head()
```
![alt text](/assets/img_20240922/image-19.png)

# ➕dateutil 모듈

### 날짜 계산: relativedelta

🔖특정 날짜를 기준으로 과거 또는 미래 날짜 계산하기
- relativedelta 객체를 이용하면 특정 날짜를 기준으로 과거 또는 미래 날짜를 계산할 수 있다.

```py
# 현재 시점을 기준으로 과거 또는 미래 시점을 연,월,일 단위로 계산
from datetime import datetime
from dateutil.relativedelta import relativedelta
 
now = datetime.now().date()
print('현재 날짜', now)
print('작년', now+relativedelta(years=-1)) 
print('두달전', now+relativedelta(months=-2)) 
print('3일 후', now+relativedelta(days=3)) 
print('1년 3달 후', now+relativedelta(years=1, months=3))
```
![alt text](/assets/img_20240922/image-20.png)

🔖두 날짜의 차이 계산
- relativedelta에서 첫 번째, 두 번째 인자에 datetime 객체를 넣어주면 두 날짜간 차이를 계산할 수 있다.

```py
year, month, day = 1981, 1, 1
res = relativedelta(now, datetime(year, month, day)) ## 현재 날짜와 1981년 1월 1일과의 날짜 차이
print(f'{res.years} years, {res.months} months, {res.days} days')
```
![alt text](/assets/img_20240922/image-21.png)

### 파싱

- 파싱: 문자열로부터 날짜 패턴을 자동으로 인식하여 datetime 객체로 변환해 주는 것.

```py
from dateutil.parser import parse
 
print(parse('20191111231519'), type(parse('20191111231519')))
print(parse('2019-11-11 23:15:19'))
print(parse('2019/11/11'))
```
![alt text](/assets/img_20240922/image-22.png)

### datetime 객체 시퀀스 생성: rrule

- dateutil에서 rrule을 이용하면 datetime 객체를 원소로 하는 시퀀스를 생성할 수 있다.

```py
from dateutil.rrule import rrule, DAILY, MONTHLY, YEARLY
from pprint import pprint
 
## 1987년 11월 11일부터 하루 단위로 datetime 객체 5개를 포함하는 리스트 생성
datetime_sequence_day = rrule(DAILY, count=5, dtstart=parse('19871111'))
## 1987년 11월 11일부터 월 단위로 datetime 객체 5개를 포함하는 리스트 생성
datetime_sequence_month = rrule(MONTHLY, count=5, dtstart=parse('19871111'))
## 1987년 11월 11일부터 연 단위로 datetime 객체 5개를 포함하는 리스트 생성
datetime_sequence_year = rrule(YEARLY, count=5, dtstart=parse('19871111'))
pprint('일 단위 시퀀스')
pprint(list(datetime_sequence_day))
pprint('월 단위 시퀀스')
pprint(list(datetime_sequence_month))
pprint('연 단위 시퀀스')
pprint(list(datetime_sequence_year))
```
![alt text](/assets/img_20240922/image-23.png)


# 029.고객 행동의 각종 통계량을 파악하자

### 각종 통계량 계산 결과

🔖매월 이용 횟수의 mean, median, max, min

```py
customer_join[["mean", "median", "max", "min"]].describe()
```
![alt text](/assets/img_20240922/image-24.png)

🔖routine_flg

```py
customer_join.groupby("routine_flg").count()["customer_id"]
```
![alt text](/assets/img_20240922/image-25.png)

🔖회원 기간의 분포

```py
import matplotlib.pyplot as plt
%matplotlib inline
plt.hist(customer_join["membership_period"])
```
![alt text](/assets/img_20240922/image-26.png)

=> 짧은 기간에 고객이 빠져나가는 업계라는 의미

# 030.탈퇴 회원과 지속 회원의 차이를 파악하자

- 탈퇴 회원: 1350명 / 지속 회원: 2840명

### 통계량 집계

🔖탈퇴한 회원

```py
customer_end = customer_join.loc[customer_join["is_deleted"]==1]
customer_end.describe()
```
![alt text](/assets/img_20240922/image-27.png)

🔖지속 회원

```py
customer_stay = customer_join.loc[customer_join["is_deleted"] == 0]
customer_stay.describe()

# 지금까지 한거 csv로!
customer_join.to_csv("customer_join.csv", index=False)
```
![alt text](/assets/img_20240922/image-28.png)

🔖 결론

- 탈퇴회원의 매월 이용 횟수의 평균, 중앙, 최솟값은 모두 지속 회원보다 작다.
  - 평균값과 중앙값은 1.5배 차이
  - 매월 최대 이용 횟수의 평균값은 탈퇴 회원도 6.4
- routine_flg는 차이가 크다.