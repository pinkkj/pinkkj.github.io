---
excerpt: "과제2(쿠버네티스에 nginx 띄우기)"
name: J
writer: J
categories: [Cloud Study, AWS Study] # [메인 카테고리, 서브 카테고리]
tags:
  - []

toc: true
toc_sticky: true

date: 2025-10-01
last_modified_at: 2025-10-01

# --- 아래 부터 content
---
# 과제
- 주제: 쿠버네티스 기반의 EKS 환경 구성과 웹 서비스 구축
    1. 쿠버네티스 환경 구축
    2. 이용하여 EKS 클러스터와 노드그룹 생성
    3. 구축된 쿠버네티스 환경에 Nginx 서비스 배포
    1) EKS cluster 생성
    2) Worker node group 생성
    3) Nginx 서비스 배포

# 실습
1. 먼저 최신버전으로 업데이트
```bash
sudo yum update -y
```
2. aws 버전 확인
```bash
aws --version
```
해서 1.18 이상이어야함 -> 이래야 kubectl 명령어가 먹음

3. IAM에서 EC2 에 제공할 admin 만들기<br>
⭐IAM > 역할 > 역할 생성 > EC2 > "AdministratorAccess" 선택<br>
⭐EC2 > 인스턴스 > (적용하고 싶은 인스턴스)우클릭 > 보안 > IAM 역할 수정
- EC2 instance를 활용해 EKS cluster도 만들고, EC2 nodegroup도 만들고 등 여러개 할거라 EC2가 그런거 제공할 권한을 줘야함

4. kubectl 설치<br>
[Kubernetes 다운로드](https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/install-kubectl.html#macos_kubectl)
```bash
uname -m
```
으로 확인하고 다운로드! aarch64 나오면 ARM64, x86_64 나오면 AMD64
<br><br>
다운로드 하고...
```bash
chmod +x ./kubectl
sudo mv ./kubectl /usr/local/bin/kubectl
kubectl version --client
```

![alt text]({{ '/assets/img_20251022/image-12.png' | relative_url }})

5. eksctl 설치
```bash
curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
```
```bash
sudo mv /tmp/eksctl /usr/local/bin
eksctl version
```

6. WorkerNode(Node(EC2 instance가 Node)group)용 ssh 키 생성: eksctl 명령으로 할거임.
- EC2 instance 생성할땐 꼭 ssh 키가 필요. 따라서 이거용 키를 만들거임. 

> EC2-user로 로그인하면....(.ssh파일이 숨김 파일로 자동으로 생성) **but** admin으로 하면 생성해줘야함.
```bash
mkdir .ssh #로 폴더 만들고 그 안에 ssh키 올리면됨
```

키 생성!! -> workernode의 키!
```bash
cd .ssh
ssh-keygen
```

생성된 키를 사용중인 EC2 리전으로 업로드(인식 가능하도록)
```bash
 aws configure set region ap-southeast-2 # 지역을 이걸로 해서..바꾸기

 aws ec2 import-key-pair --key-name "workernode-key" --public-key-material fileb://~/.ssh/id_rsa.pub
```

![alt text]({{ '/assets/img_20251022/image-3.png' | relative_url }})

7. EKS 환경 구성(nat 구성 잘 하기!)
```bash
eksctl create cluster --name mission-cluster --version 1.33 --region ap-northeast-2 \
  --nodegroup-name mission-wn --node-type m7i-flex.large\
  --nodes 1 --nodes-min 1 --nodes-max 1 \
  --ssh-access --ssh-public-key workernode-key \
  --managed --node-private-networking \
  --vpc-private-subnets subnet-01eee9d4accc43fd3,subnet-0f4f771af916997aa
```

```bash 
# kubectl과 EKS의 버전이 맞지 않을때 해결법!
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install
aws--version
aws eks update-kubeconfin --region ap-northeast-2 --name mission-cluster
```

8. 생성된 node 확인
```bash
kubectl get node
```

9. Nginx deployment 배포
```bash
cat <<EOF > ~/nginx-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-nginx
spec:
  selector:
    matchLabels:
      run: my-nginx
  replicas: 2
  template:
    metadata:
      labels:
        run: my-nginx
    spec:
      containers:
      - name: my-nginx
        image: nginx
        ports:
        - containerPort: 80
EOF
```
![alt text]({{ '/assets/img_20251022/image-13.png' | relative_url }})

```bash
#home directory에서..
kubectl apply -f nginx-deployment.yaml
kubectl get pod
```
10. Nginx service 배포
  1) Nginx-Service.yaml 생성(type: loadbalancer)
```bash
  cat <<EOF > ~/nginx-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-nginx
  labels:
    run: my-nginx
spec:
  ports:
  - port: 80
    protocol: TCP
  selector:
    run: my-nginx
  type: LoadBalancer
EOF
```

```bash
kubectl apply -f nginx-service.yaml
kubectl get service
```

11. Nginx-service, Nginx-deployment 삭제
```bash
kubectl delete -f nginx-service.yaml
kubectl delete -f nginx-deployment.yaml
```
12. EKS cluster와 Node Group 삭제
```bash
eksctl delete cluster --region ap-northeast-2 --name=mission-cluster
```
# 이론
## Kubernetes
### Kubernetes 란?
1. 컨테이너 오케스트레이션 툴 (Docker Swarm 같은...)
2. 컨테이너를 쉽고 빠르게 배포/확장하고 관리를 자동화해주는 오픈소스 플랫폼 = 컨테이너 관리 툴
3. Docker가 컨테이너 기반의 가상화를 실현한 플랫폼이라면 Docker Container를 관리하는 것이 Kubernetes!

![alt text]({{ '/assets/img_20251022/image-8.png' | relative_url }})

### 쿠버네티스 클러스터 아키텍처
1. 여러 대의 서버(노드)가 하나의 클러스터로 연결(여러 대의 서버(노드)를 하나로 묶어 파드를 배치, 운영하는 공간)
2. 쿠버네티스 마스터 = 컨트롤 플레인이 실행됨. 클러스터의 두뇌. 컨테이너 스케줄링, 서비스 관리, API 요청 수행(파드, 리소스 컨트롤러, 로드밸런서 관리)
3. 쿠버네티스 워커노드 = 사용자의 워크로드 실행. 마스터의 관리 아래 실제 pod같은 리소스가 생성되는 노드
4. kubectl: 쿠버네티스를 다루기 위한 명령행 도구

### 관리형 Kubernetes vs 자체 호스팅
1. Kubernetes를 자체적으로 구축가능(=자체 호스팅). 위의 아키텍처를 구축하고 지속적 관리 필요(쿠버네티스는 생각보다 업데이트가 빠르다...)
2. 따라서 관리형 쿠버네티스 추천 -> AWS의 EKS, Google의 GKE, Azure의 AKS. 기업에서 고가용성이 보장된 쿠버네티스 클러스터 제공

![alt text]({{ '/assets/img_20251022/image-9.png' | relative_url }})
![alt text]({{ '/assets/img_20251022/image-10.png' | relative_url }})

### Kubernetes Object

Nginx Pod 띄우고 Load Balance type으로 서비스 배포...예?

1. 쿠버네티스는 상태를 관리하기 위한 대상을 오브젝트로 정의
2. pod - 쿠버네티스의 가장 작은 배포 단위. 컨테이너의 모임. 하나 이상의 컨테이너로 구성(객체)
3. Deployment - 애플리케이션 배포의 기본 단위가 되는 리소스(클래스)
4. Service - Pod를 외부에 노출시켜주는 로드 밸런서
5. 위의 오브젝트들은 yaml 파일로 정의하여 kubectl 명령어로 반영.

=> Node(=WorkerNode)는 EKS의 NodeGroup(하나의 컴퓨터라고 생각). 컨테이너(web application 등)를 담은 Pod는 Deployment에 의해 관리된다. Deployment에서 몇 개의 파드가 얼마만큼의 자원을 사용할지, 어떤 방식으로 배포할지 정의한다. Pod는 각각의 WorkerNode에 배포되고 서비스를 통해 외부에 노출된다.(사람들이 인터넷을 통해 접근가능 하도록!)

![alt text]({{ '/assets/img_20251022/image-11.png' | relative_url }})

### Nginx 서비스 배포하려면?
1. Deployment를 정의하여 Nginx 컨테이너를 담은 pod를 띄운다.
2. pod를 loadBalancer Type의 Service를 통해 배포한다.
3. 자동 생성된 ELB를 통해 Nginx가 배포된 것을 확인한다.